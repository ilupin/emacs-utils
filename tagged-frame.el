;;; tagged-frame.el --- Enhanced functionalities about frame names  -*- lexical-binding: t; -*-

;; Copyright (C) 2017 Liu Hui

;;; Code:

(require 'subr-x)
(require 'ring)
(require 'easymenu)


;;; user-defined variables

(defvar tagged-frame-tag-num-alist nil)

(defvar tagged-frame-tag-display-alist nil)

(defvar tagged-frame-tag-predicate-alist
  '(("emacs1" . tagged-frame-emacs-predicate)
    ("emacs2" . '((mode . emacs-lisp-mode)
                  (directory . user-emacs-directory)))))

(defvar tagged-frame-tag-separator "   ")

(defvar tagged-frame-current-sign '("[" . "]"))

(defvar tagged-frame-exclude-buffers-regexp "^\\s-+")

(defvar tagged-frame-default-tag nil)

(defvar tagged-frame-display-buffer-alist nil)

(defvar tagged-frame-menu-name "Frames")
(defvar tagged-frame-menu-path nil)
(defvar tagged-frame-menu-before "Tools")


;;; tag definitions

(defvar tagged-frame-alist nil)

(defun tagged-frame-set-tag (&optional tag)
  "Set new tag for current frame.
Spaces around tag are trimmed, and empty tag means to clear."
  (interactive)
  (let ((f (selected-frame)))
    (or tag (setq tag (read-string "New tag for current frame: ")))
    (when tag
      (setq tag (string-trim tag))
      (if (assoc tag tagged-frame-alist)
          (message "Tag %s has been used." tag)
        (tagged-frame--set-tag f tag)))))

(defun tagged-frame--set-tag (f tag)
  "Assign TAG to frame F.
Spaces around tag are trimmed, and empty tag means to clear."
  ;; first remove all elements containing frame F from `tagged-frame-alist'
  (setq tagged-frame-alist
        (seq-remove (lambda (e) (eq (cdr e) f)) tagged-frame-alist))
  (if (string-empty-p tag)
      (progn
        (set-frame-parameter f 'tagged-frame-tag nil)
        (set-frame-parameter f 'tagged-frame-predicate nil))
    (set-frame-parameter f 'tagged-frame-tag tag)
    (tagged-frame-reset-buffer-predicate f)
    ;; new tag or renamed tag is added in the end
    (add-to-list 'tagged-frame-alist (cons tag f) t)))

(defun tagged-frame-get-tag (&optional f)
  (or f (setq f (selected-frame)))
  (frame-parameter f 'tagged-frame-tag))

(defun tagged-frame-tags2nums (tags)
  "Convert tags to numbers by (1) the predefined rules and (2) orders."
  (let* ((tags1 (mapcar #'car tagged-frame-tag-num-alist))
         (tags2 (seq-difference tags tags1 #'string-equal))
         (indexes (seq-difference
                   (number-sequence 1 (+ (length tags1) (length tags2)))
                   (mapcar #'cdr tagged-frame-tag-num-alist))))
    (mapcar
     (lambda (tag)
       (if (member tag tags1)
           (cdr (assoc tag tagged-frame-tag-num-alist))
         (nth (seq-position tags2 tag) indexes)))
     tags)))

(defvar tagged-frame-numtag-style-alist
  '((default
      (lambda (n tag) (format "%s:%s" n tag))
      (lambda (numtag)
        (apply #'concat (cdr (split-string numtag ":")))))
    (display
     (lambda (n tag)
       (let ((disp (cdr (assoc tag tagged-frame-tag-display-alist))))
         (format "%s-%s" n (or disp tag))))
     (lambda (numtag)
       (let ((tag (apply #'concat (cdr (split-string numtag "-")))))
         (or (car (rassoc tag tagged-frame-tag-display-alist)) tag)))))
  "Tag styles for completion, displaying, etc. For example, the
  display style of tags can be changed by
(setcdr (assoc 'display tagged-frame-numtag-style-alist)
        '((lambda (n tag) ...)
          (lambda (numtag) ...)))")

(defun tagged-frame-get-numtags (&optional style sort)
  "Return a list generated by tags and corresponding indexes."
  (let ((tags (mapcar #'car tagged-frame-alist))
        (func (cadr (assoc (or style 'default)
                           tagged-frame-numtag-style-alist)))
        nums)
    (when tags
      (setq nums (tagged-frame-tags2nums tags))
      (and sort (setq tags (mapcar
                            (lambda (n) (nth (seq-position nums n) tags))
                            (sort (copy-sequence nums) '<))
                      nums (sort (copy-sequence nums) '<)))
      (seq-mapn (lambda (n tag) (funcall func n tag)) nums tags))))

(defun tagged-frame-numtag2tag (numtag &optional style)
  "Extract tag from numtag."
  (funcall
   (nth 1 (cdr (assoc (or style 'default) tagged-frame-numtag-style-alist)))
   numtag))

(defun tagged-frame-title ()
  (let ((numtags (tagged-frame-get-numtags 'display t))
        (cur (tagged-frame-get-tag))
        (cs tagged-frame-current-sign)
        (sep tagged-frame-tag-separator)
        (tag-str ""))
    (when numtags
      (setq tag-str
            (mapconcat
             (lambda (nt)
               (let* ((tag (tagged-frame-numtag2tag nt 'display)))
                 (if (equal cur tag)
                     (format "%s%s%s" (car cs) nt (cdr cs)) nt)))
             numtags sep)))
    (format "%s%s%s"
            tag-str
            (if cur "" (format "%s%s%s%s" sep (car cs) "untitled" (cdr cs)))
            sep)))

(defun tagged-frame-add (f)
  "Add frame F to `tagged-frame-alist'."
  (with-selected-frame f
    (let ((tag (tagged-frame-get-tag)))
      (if (not tag)
          (tagged-frame-set-tag "")
        (tagged-frame-set-tag tag)))))

(defun tagged-frame-initialize ()
  "Initialize `tagged-frame-alist'."
  (interactive)
  (setq tagged-frame-alist nil)
  (dolist (f (frame-list)) (tagged-frame-add f)))

(defun tagged-frame-delete (f)
  "Remove frame F from `tagged-frame-alist'."
  (when (and f (rassq f tagged-frame-alist))
    (setq tagged-frame-alist
          (seq-remove (lambda (e) (eq (cdr e) f)) tagged-frame-alist)))
  ;; if frame F has been deleted
  (setq tagged-frame-alist
        (seq-remove (lambda (e) (not (frame-live-p (cdr e)))) tagged-frame-alist)))

(define-minor-mode tagged-frame-mode "Add tags to frames."
  :global t
  :group 'tagged-frame
  (if tagged-frame-mode
      (progn
        (tagged-frame-initialize)
        (add-hook 'delete-frame-functions 'tagged-frame-delete)
        (add-hook 'after-make-frame-functions 'tagged-frame-add)
        (add-to-list 'frame-title-format '(:eval (tagged-frame-title))))
    (setq frame-title-format (delete '(:eval (tagged-frame-title)) frame-title-format))
    (setq tagged-frame-alist nil)
    (remove-hook 'delete-frame-functions 'tagged-frame-delete)
    (remove-hook 'after-make-frame-functions 'tagged-frame-add)))


;;; switch frames

(defvar tagged-frame--ring (make-ring 10)
  "Visited frame tags by order (current frame not included).")

(defmacro tagged-frame-quit-and-run (&rest body)
  "Quit the minibuffer and run BODY afterwards."
  `(progn
     (put 'quit 'error-message "")
     (run-at-time nil nil
                  (lambda ()
                    (put 'quit 'error-message "Quit")
                    ,@body))
     (minibuffer-keyboard-quit)))

(defvar tagged-frame-minibuffer-map
  (let ((map (copy-keymap minibuffer-local-must-match-map)))
    (define-key map [remap tagged-frame-switch]
      (lambda () (interactive)
        (tagged-frame-quit-and-run (tagged-frame-other))))
    (dolist (key (number-sequence 0 9))
      (define-key map (number-to-string key)
        `(lambda () (interactive)
           (tagged-frame-quit-and-run (tagged-frame-switch-index ,key)))))
    (define-key map "\C-s" (lambda () (interactive) (tagged-frame-quit-and-run (tagged-frame-set-tag))))
    (define-key map "\C-o" (lambda () (interactive) (tagged-frame-quit-and-run (tagged-frame-other))))
    (define-key map "\C-r" (lambda () (interactive) (tagged-frame-quit-and-run (tagged-frame-switch-buffer-back))))
    (define-key map "\C-n" (lambda () (interactive) (tagged-frame-quit-and-run (tagged-frame-new))))
    (define-key map "\C-p" (lambda () (interactive) (tagged-frame-quit-and-run (hydra-tagged-frame-predicate/body))))
    map)
  "Keymap for frame switching in minibuffer.")

(defun tagged-frame-read (prompt collection)
  "Wrapper for reading tag from COLLECTION with PROMPT."
  (interactive)
  (if (window-minibuffer-p)
      (user-error "Already in minibuffer")
    (let ((minibuffer-local-must-match-map tagged-frame-minibuffer-map)
          (completing-read-function 'completing-read-default)
          ;; (d (unless (ring-empty-p tagged-frame--ring)
          ;;      (ring-ref tagged-frame--ring 0)))
          )
      (completing-read prompt collection nil t))))

(defun tagged-frame--switch (tag)
  "Switch to the frame with tag TAG."
  (let ((last (tagged-frame-get-tag)))
    (unless (equal tag last)
      (select-frame-set-input-focus (cdr (assoc tag tagged-frame-alist)))
      (ring-insert tagged-frame--ring last))))

(defun tagged-frame-switch ()
  "Switch"
  (interactive)
  (or tagged-frame-mode (error "Tagged frame mode is off."))
  (let ((numtags (tagged-frame-get-numtags))
        (new-frame "*new frame*")
        (prompt "Switch to frame: ")
        input)
    (setq numtags (append numtags (list new-frame)))
    (setq input (tagged-frame-read prompt numtags))
    (when input
      (cond
       ((string-equal input new-frame)
        (tagged-frame-new))
       ((not (string-empty-p input))
        (tagged-frame--switch (tagged-frame-numtag2tag input)))))))

(defun tagged-frame-switch-index (i)
  "Switch to the frame with index I."
  (interactive)
  (or tagged-frame-mode (error "Tagged frame mode is off."))
  (let* ((tags (mapcar #'car tagged-frame-alist))
         (nums (tagged-frame-tags2nums tags))
         (n (seq-position nums i)))
    (if n
        (tagged-frame--switch (nth n tags))
      (message "No available frame."))))

(defun tagged-frame-new (&optional tag)
  "Make a new frame with TAG."
  (interactive)
  (or tag (setq tag (read-string "Tag for new frame: ")))
  (when tag
    (let ((f (make-frame)))
      (with-selected-frame f (tagged-frame-set-tag tag))
      (tagged-frame--switch tag))))

(defun tagged-frame-other ()
  "Switch to the recent tag."
  (interactive)
  (if (ring-empty-p tagged-frame--ring)
      (message "No other frame.")
    (tagged-frame--switch (ring-ref tagged-frame--ring 0))))

(defun tagged-frame-next (arg)
  "Switch to next tagged frame."
  (interactive "p")
  (or tagged-frame-mode (error "Tagged frame mode is off."))
  (let* ((tags (mapcar #'car tagged-frame-alist))
         (nums (tagged-frame-tags2nums tags)) n)
    (if (not tags)
        (message "No tagged frames.")
      (setq tags (mapcar
                  (lambda (n) (nth (seq-position nums n) tags))
                  (sort (copy-sequence nums) '<))
            n (seq-position tags (tagged-frame-get-tag)))
      (if (= arg 1)
          (if (or (not (numberp n))
                  (= n (1- (length tags))))
              (tagged-frame--switch (nth 0 tags))
            (tagged-frame--switch (nth (1+ n) tags)))
        (if (or (not (numberp n))
                (= n 0))
            (tagged-frame--switch (nth (1- (length tags)) tags))
          (tagged-frame--switch (nth (1- n) tags)))))))

(defun tagged-frame-prev ()
  "Switch to previous tagged frame."
  (interactive)
  (tagged-frame-next -1))


;;; menu

(defvar tagged-frame--menu nil)

(defun tagged-frame-create-menu (&optional _menu)
  "Create menus for tagged frames."
  (let ((m (mapcar
            (lambda (x) (vector x `(lambda () (interactive)
                                     (tagged-frame--switch ,x) t)))
            (mapcar #'car tagged-frame-alist))))
    (append
     (list ["Refresh..." tagged-frame-initialize])
     m
     (and m (list "---"))
     (list ["Next frame" tagged-frame-next]
           ["Previous frame" tagged-frame-prev]))))

(defun tagged-frame-toggle-menu (arg)
  "Show menu if ARG is 1, or hide menu otherwise.
Toggle menu if no argument is given."
  (interactive "P")
  (unless arg (setq arg (if tagged-frame--menu -1 1)))
  (if (and (numberp arg) (= arg 1))
      (unless tagged-frame--menu
        (easy-menu-add-item
         (lookup-key global-map [menu-bar]) tagged-frame-menu-path
         (list tagged-frame-menu-name :filter 'tagged-frame-create-menu)
         tagged-frame-menu-before)
        (setq tagged-frame--menu t))
    (when tagged-frame--menu
      (easy-menu-remove-item
       (lookup-key global-map [menu-bar])
       tagged-frame-menu-path
       tagged-frame-menu-name)
      (setq tagged-frame--menu nil))))


;;; Definition of buffer predicates

(defun tagged-frame-emacs-predicate (buf)
  (with-current-buffer buf
    (let ((f (or (buffer-file-name) (buffer-name))))
      (or (eq major-mode 'emacs-lisp-mode)
          (file-in-directory-p f user-emacs-directory)
          (file-equal-p f user-init-file)))))

(defun tagged-frame-reset-buffer-predicate (&optional f)
  "Reset buffer predicates of frame F."
  (interactive)
  (or f (setq f (selected-frame)))
  ;; (set-frame-parameter f 'tagged-frame-dedicated-buffers nil)
  (set-frame-parameter f 'tagged-frame-predicate
                       (cdr (assoc (tagged-frame-get-tag f)
                                   tagged-frame-tag-predicate-alist))))

(defun tagged-frame-set-buffer-predicate (type)
  "Set or add buffer predicate of type TYPE for current frame.
Available types include directory, mode, and regexp. A frame can
have multiple directory and mode predicates, but can have only
one regexp predicate."
  (interactive)
  (let ((p (frame-parameter nil 'tagged-frame-predicate)) x)
    (when (not (listp p))
      (unless (y-or-n-p "Overwrite the predicate function?")
        (error "A predicate function has been defined for current frame."))
      (setq p nil))
    (cond
     ((eq type 'directory)
      (setq x (read-directory-name "Add directory predicate: ")))
     ((eq type 'mode)
      (setq x major-mode)
      (message "Mode predicate added."))
     ((eq type 'regexp)
      (setq x (read-regexp
               (format "Set regexp predicate (default %s): "
                       (regexp-quote (buffer-name)))
               (regexp-quote (buffer-name))))))
    (if (member type '(directory mode))
        (unless (member (cons type x) p)
          (push (cons type x) p))
      (if (assq type p)
          (setcdr (assq type p) x)
        (push (cons type x) p)))
    (set-frame-parameter nil 'tagged-frame-predicate p)))

(defun tagged-frame-translate-predicates (alist)
  "Translate buffer predicates ALIST to a simple predicate function."
  (let ((mode (delete nil (mapcar (lambda (e) (and (eq (car e) 'mode) (cdr e))) alist)))
        (dirs (delete nil (mapcar (lambda (e) (and (eq (car e) 'directory) (cdr e))) alist)))
        (regex (cdr (assq 'regexp alist)))
        (regex-not (cdr (assq 'regexp-exclude alist))))
    `(lambda (buf)
       (with-current-buffer buf
         (let ((f (or (buffer-file-name) (buffer-name))))
           (and
            (or ,(if mode `(member major-mode ',mode))
                ,(if dirs `(seq-some (lambda (d) (file-in-directory-p f d)) ',dirs))
                ,(if regex `(string-match-p ,regex f)))
            (not ,(if regex-not `(string-match-p ,regex-not f)))))))))

(defun tagged-frame-show-predicates ()
  (interactive)
  (let ((p (frame-parameter nil 'tagged-frame-predicate)))
    (if p (message "%s" p) (message "No buffer predicate is set."))))


;;; buffer operations

(defvar tagged-frame--switch-buffer-function nil
  "Used by other library (ido ...).")

(defun tagged-frame--remove-buffer (buffer-or-name)
  "Remvoe buffer BUF from the buffer-list of selected frame."
  (let ((bl (frame-parameter nil 'buffer-list))
        (buf (get-buffer buffer-or-name)))
    (when (member buf bl)
      (setq bl (delete buf bl))
      (set-frame-parameter nil 'buffer-list bl))))

(defun tagged-frame-relocate-buffer (&optional buffer-or-name)
  "Relocate BUF or current buffer to another frame."
  (interactive)
  (let* ((cur (current-buffer))
         (buf (get-buffer (or buffer-or-name cur)))
         (text (if (eq buf cur) "Target frame for current buffer: "
                 (format "Target frame for %s: " (buffer-name buf))))
         (numtag (tagged-frame-read text (tagged-frame-get-numtags))))
    (when numtag
      (when (eq buf cur)
        (switch-to-buffer (other-buffer))
        (tagged-frame--remove-buffer buf))
      (tagged-frame--switch (tagged-frame-numtag2tag numtag))
      ;; TODO add action restricting the same frame
      (pop-to-buffer buf))))

(defun tagged-frame-switch-buffer-back (&optional buffer-or-name)
  "Switch to current buffer (or other buffer if ARG is non-nil)
in last frame."
  (interactive)
  (if (ring-empty-p tagged-frame--ring)
      (message "No last frame.")
    (let ((buf (get-buffer (or buffer-or-name (current-buffer)))))
      (and (fboundp 'winner-undo) (winner-undo))
      (tagged-frame--switch (ring-ref tagged-frame--ring 0))
      (switch-to-buffer buf))))

;; (defun tagged-frame-display-buffer (buf tag)
;;   (and buf tag))

(defun tagged-frame-switch-to-buffer (arg)
  "Switch to BUF in a specific frame. Only for interactive use."
  (interactive "P")
  (if arg
      (call-interactively 'switch-to-buffer)
    (if (functionp tagged-frame--switch-buffer-function)
        (funcall tagged-frame--switch-buffer-function)
      (tagged-frame--switch-to-buffer
       (read-buffer-to-switch "Switch to buffer: ")))))

(defun tagged-frame-find-file (filename &optional wildcards)
  "Edit file FILENAME."
  (interactive
   (find-file-read-args "Find file: "
                        (confirm-nonexistent-file-or-buffer)))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
	(mapcar 'tagged-frame--switch-to-buffer (nreverse value))
      (tagged-frame--switch-to-buffer value))))

(defun tagged-frame--switch-to-buffer (buffer-or-name)
  "Switch to BUFFER-OR-NAME."
  (let ((buf (get-buffer buffer-or-name)))
    (if (or (not buf)
            (not tagged-frame-mode)
            (not (tagged-frame-get-tag))
            (string-match-p tagged-frame-exclude-buffers-regexp
                            (buffer-name buf)))
        (switch-to-buffer buffer-or-name)
      (let ((tag (tagged-frame-which-tag buf))
            (cur (tagged-frame-get-tag)))
        (if (or (not tag) (equal tag cur))
            (switch-to-buffer buf)
          ;; delete buf from buffer-list of old frame
          (tagged-frame--remove-buffer buf)
          (tagged-frame--switch tag)
          ;; pop or switch?? TODO: change to (display-buffer buf alist)
          (pop-to-buffer buf))))))

(defun tagged-frame-which-tag (buf)
  "Return the tag of the frame that should be raised when switching to BUF.
If no tag is found and `tagged-frame-default-tag' has been used
for some frame, return it."
  (let ((fs (seq-remove (lambda (f) (not (tagged-frame-get-tag f))) (frame-list)))
        tag f)
    (when fs
      (while (and (not tag) fs)
        (setq f (pop fs))
        (if (tagged-frame-buffer-dedicated-p f buf)
            (setq tag (car (rassq f tagged-frame-alist))))))
    (or tag
        (and (assoc tagged-frame-default-tag tagged-frame-alist)
             tagged-frame-default-tag))))

(defun tagged-frame-buffer-dedicated-p (frame buf)
  "Return non-nil if BUF is associated with FRAME."
  (let ((p (frame-parameter frame 'tagged-frame-predicate)))
    (when p
      (cond
       ((functionp p) (funcall p buf))
       ((listp p) (funcall (tagged-frame-translate-predicates p) buf))))))


;;; enhancement and compatibility with other packages

(defun tagged-frame-add-hydra ()

  (define-key tagged-frame-minibuffer-map "\C-o"
    (lambda () (interactive) (tagged-frame-quit-and-run (hydra-tagged-frame/body))))

  (defhydra hydra-tagged-frame (:color blue :columns nil)
    "Actions"
    ("s" tagged-frame-set-tag "set tag")
    ("o" tagged-frame-other "other")
    ("n" tagged-frame-next "next" :exit nil)
    ("p" tagged-frame-prev "prev" :exit nil)
    ("N" tagged-frame-new "new")
    ("P" hydra-tagged-frame-predicate/body "predicate")
    ("0" (tagged-frame-switch-index 0) nil)
    ("1" (tagged-frame-switch-index 1) nil)
    ("2" (tagged-frame-switch-index 2) nil)
    ("3" (tagged-frame-switch-index 3) nil)
    ("4" (tagged-frame-switch-index 4) nil)
    ("5" (tagged-frame-switch-index 5) nil)
    ("6" (tagged-frame-switch-index 6) nil)
    ("7" (tagged-frame-switch-index 7) nil)
    ("8" (tagged-frame-switch-index 8) nil)
    ("9" (tagged-frame-switch-index 9) nil)
    ("q" nil nil))

  (defhydra hydra-tagged-frame-predicate (:color blue :columns nil)
    "Buffer predicates"
    ("d" (tagged-frame-set-buffer-predicate 'directory) "directory (add)")
    ("m" (tagged-frame-set-buffer-predicate 'mode) "major mode (add)")
    ("r" (tagged-frame-set-buffer-predicate 'regexp) "regexp (set)")
    ("R" tagged-frame-reset-buffer-predicate "Reset")
    ("S" tagged-frame-show-predicates "Show")
    ("q" nil nil))
  )

(defvar ivy-text)
(defvar ivy--virtual-buffers)
(defvar ivy-views)
(declare-function ivy-add-actions "ivy")
(declare-function with-ivy-window "ivy")
(declare-function ivy-set-view-recur "ivy")

(defun tagged-frame-add-ivy ()
  "Use `ivy-switch-buffer'."

  (setq tagged-frame--switch-buffer-function 'ivy-switch-buffer)

  (ivy-add-actions
   'ivy-switch-buffer
   '(("f"
      (lambda (buffer)
        (tagged-frame-relocate-buffer buffer))
      "show buffer in frame")))

  (ivy-add-actions
   'ivy-switch-buffer
   '(("J"
      (lambda (buffer)
        (tagged-frame--switch-to-buffer buffer))
      "window in other frame")))

  (defun ivy--switch-buffer-action (buffer)
    "Switch to BUFFER.
BUFFER may be a string or nil."
    (with-ivy-window
      (if (zerop (length buffer))
          (tagged-frame--switch-to-buffer ivy-text)
        (let ((virtual (assoc buffer ivy--virtual-buffers))
              (view (assoc buffer ivy-views)))
          (cond ((and virtual
                      (not (get-buffer buffer)))
                 (tagged-frame-find-file (cdr virtual)))
                (view
                 (delete-other-windows)
                 (let (
                       ;; silence "Directory has changed on disk"
                       (inhibit-message t))
                   (ivy-set-view-recur (cadr view))))
                (t
                 (tagged-frame--switch-to-buffer buffer)))))))
  )

(provide 'tagged-frame)

;;; tagged-frame.el ends here
